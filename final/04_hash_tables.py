print("\n---Хэш-таблицы. Что это такое и как работают? Балакирев")

# Хэш-таблица обладает поистине впечатляющими характеристиками.
# Для стандартных операций вставки, чтения и удаления данных она, в среднем,
# выполняется за константное время O(1),
# то есть, быстро и не зависимо от размера таблицы (объема данных)

# Алгоритм преобразования некоторой строки в индекс массива получил название хэш-функция,
# а процесс его работы – хэширование. Отсюда пошло название хэш-таблица.

print("\n---Свойства хэш-функции")
# - для одного и того же ключа (названия товара)
#   должна выдавать одно и то же значение (свойство последовательности);
# - для разных ключей (названий товаров) выдавать разные значения (индексы);
# - формируемые значения должны находиться в диапазоне от 0 до N-1,
#   где N – размер массива, т.е. индексы должны быть действительными
#   для используемой таблицы;
# - возможные ключи (названия) должны равномерно записываться в ячейки таблицы.

print("""
b -> hash_func() -> ptr -> b,б              (Работа хэш-функции [0,4])

                 b,б   d,д  f,ф  u,у
                   ^    ^    ^    ^
                   |    |    |    |
HashTable = None, ptr, ptr, ptr, ptr        (Хэш-таблица со ссылками на объекты)

И наша Хэш-таблица почти заполнена!
""")

print("""
В теории хэш-таблиц
степень их заполненности определяется коэффициентом: α = n / m
n – количество хранимых ключей (в нашем примере 4); m – размер массива (в нашем примере 5). Получаем, значение степени заполнения таблицы:

α = 4 / 5 = 0,8
Если α < 1    | массиве есть свободные элементы
Если α = 1    | массив заполнен полностью
Если α > 1    | этот случай рассмотрим ниже
""")

print("""
Увеличиваем размер хэш-таблицы в 2 раза:
1. создаем в памяти новый массив в 2 раза больше существующего
2. заново прогоняем все элементы через новую хэш-функцию [0,9]
В среднем, эта операция выполняется за фиксированное время O(1)
Получаем:
                        b,б        d,д  f,ф              u,у
                         ^          ^    ^                ^
                         |          |    |                |
HashTable = None, None, ptr, None, ptr, ptr, None, None, ptr, None
""")

print("""
Разрешение коллизий
На практике, когда число значений очень велико хэш-функция начинает назначать
им повторяющиеся индексы (алгоритмически мы должны обеспечивать
не только различие в индексах, но и равномерность заполнения таблицы)
Два основных метода разрешения коллизий:
- метод цепочек
- метод открытой адресации
""")

print("""
Метод цепочек
чтобы сохранить несколько разных ключей по одному и тому же индексу,
формируется двусвязный список, на начало которого ведет указатель ptr
Получаем:
                        bа,ба           fа,фа
                         ^|              ^|                
                         |v              |v                
                        b,б        d,д  f,ф              u,у
                         ^          ^    ^                ^
                         |          |    |                |
HashTable = None, None, ptr, None, ptr, ptr, None, None, ptr, None

Плюсы: Простота реализации
Минусы: Есть возможность образования длинных цепочек => снижение скорости поиска

Чтобы избежать образования длинных цепочек важно правильно выбирать хэш-функцию
""")
